# -*- coding: utf-8 -*-
import re
from typing import Dict, List, Tuple, Optional

class SentimentAnalyzer:
    
    def __init__(self):
        self._compile_patterns()
        self._init_data()

    def _compile_patterns(self):
        # é¢„ç¼–è¯‘é€šç”¨æ­£åˆ™ï¼Œæå‡é«˜å¹¶å‘æ€§èƒ½
        self.re_repeat_chars = re.compile(r"(.)\1{2,}")  # æ£€æµ‹é‡å¤å­—ç¬¦ (å¦‚ "å•Šå•Šå•Š")
        self.re_question = re.compile(r"(ä½ |æ‚¨|ç‰¹|çš‡|æ®¿).*[?ï¼Ÿå—]") # æ£€æµ‹æé—®ï¼Œé˜²æ­¢è‡ªä½œå¤šæƒ…

    def _init_data(self):
        # ==================== 1. æƒ…ç»ªèŠ‚ç‚¹é…ç½® (æè‡´æ‰©å……) ====================
        # ä¼˜å…ˆçº§(Priority): 0=æ™®é€š, 1=é«˜ä¼˜å…ˆ(è¦†ç›–), 2=ç»å¯¹ä¼˜å…ˆ(ç†”æ–­/ç´§æ€¥)
        
        self.EMOTION_NODES = {
            # === åœºæ™¯ï¼šæ—©å®‰ / å¯åŠ¨ ===
            # å¯¹åº”è¯­éŸ³ï¼šé—®å€™ ("åšå£«ï¼Œæ—©ä¸Šå¥½")
            "morning": {
                "keywords": [
                    "æ—©å®‰", "æ—©ä¸Šå¥½", "æ—©å•Š", "å“¦å“ˆå“Ÿ", "æ—©", "å¯åŠ¨", "é†’äº†", 
                    "èµ·é£", "morning", "hi", "å“ˆå–½", "ä½ å¥½", "æ‚¨å¥½", "æ—©ä¸Š", 
                    "åˆšé†’", "å›°æ­»", "ççœ¼", "æç¥", "å’–å•¡", "æ‰“å¡"
                ],
                "regex": [r"æ—©$", r"æ—©.*å¥½", r"^æ—©", r"morning"],
                "emojis": ["ğŸŒ…", "â˜•", "ğŸ”", "â˜€ï¸", "ğŸ‘‹", "ğŸ¥ª", "ğŸ¥›"],
                "base_score": 6.0,
                "priority": 0
            },

            # === åœºæ™¯ï¼šç´¯ / ä¼‘æ¯ / é—²ç½® ===
            # å¯¹åº”è¯­éŸ³ï¼šé—²ç½® ("ç´¯äº†å—ï¼Ÿé‚£å°±ä¼‘æ¯å§")
            "sanity": {
                "keywords": [
                    # åŸºç¡€
                    "æ™šå®‰", "ç¡äº†", "ç¡è§‰", "ç´¯", "ä¼‘æ¯", "å›°", "ä¼‘çœ ", "ä¸‹ç­", 
                    "åˆç¡", "èººå¹³", "æ­‡ä¼š", "ä¹", "å€¦", "æŒ‚æœº",
                    # æ˜æ—¥æ–¹èˆŸé»‘è¯
                    "ç†æ™º", "ç¢çŸ³", "åƒçŸ³å¤´", "æ“ç‰", "è‚", "1-7", "åˆ·ææ–™", 
                    "é•¿è‰", "åŸºå»º", "æ’ç­", "æ¢ç­", "æ¸…ç†æ™º", "å‰¿ç­", "ä»£ç†",
                    # ç¤¾ç•œ/å­¦ç•œ
                    "åŠ ç­", "çŒæ­»", "é€šå®µ", "ç†¬å¤œ", "åšé¢˜", "èµ¶ddl", "å¼€ä¼š",
                    "æ‘¸é±¼", "ä¸æƒ³åŠ¨", "ç˜«", "ç´¯æ­»"
                ],
                "regex": [
                    r"(å»|è¦|æƒ³)ç¡", r"å¥½{0,2}ç´¯", r"å›°.*æ­»", r"çœ¼.*çä¸å¼€", 
                    r"è‚.*ç–¼", r"ç†.*æ™º.*(æ— |æ²¡|å…‰|0)", r"ä¸‹.*ç­", r"æ™š.*å®‰"
                ],
                "emojis": ["ğŸ’¤", "ğŸŒ™", "ğŸ›Œ", "ğŸ¥±", "ğŸ˜ª", "ğŸŒƒ", "ğŸ”‹", "ğŸª«"],
                "base_score": 6.0,
                "priority": 0
            },

            # === åœºæ™¯ï¼šæ‚²ä¼¤ / ç—›è‹¦ / ç ´é˜² (é«˜ä¼˜å…ˆ) ===
            # å¯¹åº”è¯­éŸ³ï¼šä½œæˆ˜ä¸­4 ("åˆ«å“­ï¼Œå¾ˆå¿«å°±ç»“æŸäº†")
            "dont_cry": {
                "keywords": [
                    # åŸºç¡€
                    "ç—›è‹¦", "æƒ³å“­", "éš¾å—", "ä¼¤å¿ƒ", "æ‚²ä¼¤", "æµæ³ª", "å“­",
                    # æµè¡Œè¯­
                    "ç ´é˜²", "å´©æºƒ", "ç”šè‡³æƒ³ç¬‘", "emo", "å‘œ", "ç‰ç‰", "åœ°ç‹±", 
                    "å¯„", "ä¼¼äº†", "è£‚å¼€", "éº»äº†", "å°ä¸‘", "çº¢æ¸©", "å¿ƒæ€å´©",
                    "è‡´éƒ", "åˆ€", "å‘ç—…", "é—æ†¾", "å”‰", "å¹æ°”"
                ],
                "regex": [
                    r"å¥½{0,2}(ç—›|è‹¦)", r"å‘œ{3,}", r"ä¸æƒ³.*æ´»", r"å¿ƒ.*æ€.*å´©", 
                    r"ç ´.*å¤§.*é˜²", r"æ•‘.*æˆ‘", r"ç¬‘.*ä¸.*å‡º.*æ¥"
                ],
                "emojis": ["ğŸ˜­", "ğŸ˜¢", "ğŸ’”", "ğŸ¥€", "ğŸ’§", "ğŸŒ§ï¸", "ğŸ˜¿", "ğŸ˜", "ğŸ©¸"],
                "base_score": 7.5,
                "priority": 1
            },

            # === åœºæ™¯ï¼šææƒ§ / æ•‘å‘½ (æœ€é«˜ä¼˜å…ˆ) ===
            # å¯¹åº”è¯­éŸ³ï¼šé€‰ä¸­å¹²å‘˜2 ("åˆ«æ€•ï¼Œæˆ‘åœ¨")
            "comfort": {
                "keywords": [
                    "æ•‘å‘½", "å®³æ€•", "ææ€–", "å“äºº", "å§”å±ˆ", "æ€•", "é˜´é—´", 
                    "å™©æ¢¦", "é¬¼", "ç„¦è™‘", "ç´§å¼ ", "å‹åŠ›", "çª’æ¯", "æ…Œ", 
                    "help", "sos", "ä¸æ•¢", "å‘æŠ–", "å“æ­»"
                ],
                "regex": [
                    r"è¢«.*å“", r"å¥½{0,2}æ€•", r"æ•‘.*å‘½", r"å“.*æ­»", 
                    r"åˆ«.*å“.*æˆ‘", r"å¸®.*å¸®.*æˆ‘"
                ],
                "emojis": ["ğŸ˜±", "ğŸ˜¨", "ğŸ˜–", "ğŸ†˜", "ğŸ‘»", "ğŸ§Ÿ", "ğŸ•·ï¸", "ğŸ˜°"],
                "base_score": 8.0,
                "priority": 2
            },

            # === åœºæ™¯ï¼šå¤±è´¥ / æŒ«æŠ˜ / æ°”é¦ ===
            # å¯¹åº”è¯­éŸ³ï¼šè¡ŒåŠ¨å¤±è´¥ ("æˆ‘ä»¬ä¸€å®šå¯ä»¥è·¨è¿‡è¿™äº›ä¼¤ç—›")
            "fail": {
                "keywords": [
                    # åŸºç¡€
                    "å¤±è´¥", "è¾“äº†", "ç™½ç»™", "å¦‚æœ", "å‡å¦‚", "åæ‚”", "èœ", "å¼±",
                    # æ¸¸æˆ/æŠ½å¡
                    "æ²‰èˆ¹", "ä¿åº•", "è“å¤©ç™½äº‘", "ç´«æ°”ä¸œæ¥", "æ½œèƒ½", "æ­ªäº†", 
                    "æ¼æ€ª", "ä»£ç†å¤±è¯¯", "æ¼”æˆ‘", "ä¸è¡€", "ç¿»è½¦", "æ‰‹æ®‹", 
                    "è„‘æº¢è¡€", "è¡€å‹", "ä¸‹é¥­", "æ“ä½œå˜å½¢", "æ‰“ä¸è¿‡", "å¡å…³"
                ],
                "regex": [
                    r"æ‰“.*ä¸è¿‡", r"è¿‡.*ä¸å»", r"è¾“.*äº†", r"é«˜.*è¡€.*å‹", 
                    r"æŠ½.*ä¸.*åˆ°", r"æ­ª.*äº†"
                ],
                "emojis": ["ğŸ³ï¸", "ğŸ’€", "ğŸ‘", "ğŸ¤¡", "ğŸ“‰", "ğŸ’©"],
                "base_score": 6.0,
                "priority": 0
            },

            # === åœºæ™¯ï¼šå­¤ç‹¬ / é™ªä¼´ ===
            # å¯¹åº”è¯­éŸ³ï¼šéƒ¨ç½²2 ("æˆ‘åœ¨è¿™å„¿å‘¢")
            "company": {
                "keywords": [
                    "å­¤ç‹¬", "å¯‚å¯", "æ²¡äºº", "ä¸€ä¸ªäºº", "æ— èŠ", "å†·æ¸…", "ç†æˆ‘", 
                    "è‡ªé—­", "å­¤å•", "è½å¯", "ç©ºè™š", "æ²¡äººçˆ±", "å­¤å¯¡", 
                    "åªæœ‰ä½ ", "é™ªæˆ‘", "èŠèŠ", "è¯´è¯"
                ],
                "regex": [
                    r"ç†.*æˆ‘", r"åœ¨.*å—", r"æ²¡.*äºº", r"ä¸€.*ä¸ª.*äºº", r"é™ª.*é™ª.*æˆ‘"
                ],
                "emojis": ["ğŸƒ", "ğŸ‚", "ğŸª¹", "ğŸ˜¶", "ğŸŒ«ï¸", "ğŸš¶"],
                "base_score": 5.0,
                "priority": 0
            },

            # === åœºæ™¯ï¼šä¿¡èµ– / çˆ±æ„ / æ’’å¨‡ ===
            # å¯¹åº”è¯­éŸ³ï¼šä¿¡èµ–è§¦æ‘¸ ("æˆ‘åœ¨æ³¨è§†ç€ä½ ")
            "trust": {
                "keywords": [
                    # ç§°å‘¼
                    "è€å©†", "ç‰¹é›·è¥¿å¨…", "æ®¿ä¸‹", "çš‡å¥³", "ç‰¹è•¾è¥¿å¨…", "å¥³ç‹",
                    # åŠ¨ä½œ/æƒ…æ„Ÿ
                    "æŠ±æŠ±", "è´´è´´", "å–œæ¬¢", "çˆ±", "å¤ªå¼º", "å‰å®³", "æƒ³ä½ ", 
                    "äº²äº²", "ç»“å©š", "æˆ’æŒ‡", "ç¾ç»Š", "æƒ³å¿µ", "å¿ƒåŠ¨", "å¯çˆ±",
                    "æ¸©æŸ”", "å¤©ä½¿", "å¦ˆå¦ˆ", "æˆ‘çˆ±ä½ ", "love"
                ],
                "regex": [
                    r"æœ€.*å–œæ¬¢", r"çˆ±.*ä½ ", r"æƒ³.*ä½ ", r"ç»“.*å©š", r"è€.*å©†", 
                    r"è´´.*è´´", r"æŠ±.*æŠ±"
                ],
                "emojis": ["â¤ï¸", "ğŸ¥°", "ğŸ¤—", "ğŸ˜˜", "ğŸ’", "ğŸŒ¹", "âœ¨", "ğŸ˜»", "ğŸ’•"],
                "base_score": 5.0,
                "priority": 0
            },

            # === åœºæ™¯ï¼šäº’åŠ¨ / æˆ³ä¸€æˆ³ ===
            # å¯¹åº”è¯­éŸ³ï¼šæˆ³ä¸€ä¸‹ ("å“ˆï¼è¢«å“åˆ°äº†å—ï¼Ÿ")
            "poke": {
                "keywords": [
                    "æˆ³", "æ‰", "æ‘¸", "æ£", "rua", "æ", "æ•²", "æ‹", 
                    "æ‘¸æ‘¸", "æ‘¸å¤´", "æŠŠç©", "æŒ‡æŒ‡ç‚¹ç‚¹"
                ],
                "regex": [r"æˆ³.*æˆ³", r"æ‘¸.*æ‘¸"],
                "emojis": ["ğŸ‘ˆ", "ğŸ‘†", "ğŸ¤", "ğŸ‘‹"],
                "base_score": 4.0,
                "priority": 0
            }
        }

        # ==================== 2. çŸ¢é‡ä¿®é¥°ç¬¦é…ç½® ====================
        self.MODIFIERS = {
            # å¢å¼º (Multipliers > 1.0)
            "super":  {
                "words": [
                    "å¥½", "å¤ª", "çœŸ", "éå¸¸", "è¶…çº§", "æ­»", "ç‰¹åˆ«", "å·¨", "æå…¶", 
                    "è¶…", "çˆ†", "ç»", "é¡¶çº§", "å‰§çƒˆ", "ç©¶æ", "å®Œå…¨", "å½»åº•"
                ], 
                "weight": 1.5
            },
            "mid": {
                "words": ["æ¯”è¾ƒ", "è¿˜", "æŒº", "è›®", "ç›¸å½“"], 
                "weight": 1.2
            },
            # å‰Šå¼± (Multipliers < 1.0)
            "little": {
                "words": ["ä¸€ç‚¹", "æœ‰ç‚¹", "æœ‰äº›", "ä¼¼", "å¾®", "ç¨"], 
                "weight": 0.8
            },
            # å¦å®š (Weight < 0, åè½¬åˆ†æ•°)
            "negate": {
                "words": [
                    "ä¸", "æ²¡", "åˆ«", "å‹¿", "æ— ", "é", "å‡", "è«", 
                    "æœª", "å¦", "ç¦æ­¢"
                ], 
                "weight": -1.0
            }
        }
        
        # å‘å‰æœç´¢ä¿®é¥°ç¬¦çš„çª—å£å¤§å° (å­—ç¬¦æ•°)
        self.WINDOW_SIZE = 6

    def analyze(self, text: str, enable_negation: bool = True) -> Tuple[Optional[str], float]:
        """
        æ ¸å¿ƒæƒ…æ„Ÿåˆ†æé€»è¾‘
        :param text: è¾“å…¥æ–‡æœ¬
        :return: (æœ€ä½³æ ‡ç­¾, æœ€ç»ˆå¾—åˆ†)
        """
        text_lower = text.lower()
        final_scores = {tag: 0.0 for tag in self.EMOTION_NODES}
        max_priorities = {tag: 0 for tag in self.EMOTION_NODES}

        # --- Step 1: å…¨å±€ç‰¹å¾åŠ æˆ ---
        global_boost = 1.0
        
        # 1. æ ‡ç‚¹ç¬¦å·æƒ…ç»ªå¢å¼º
        if "!" in text or "ï¼" in text: global_boost += 0.2
        if "..." in text or "â€¦" in text: global_boost += 0.1
        
        # 2. å­—ç¬¦é‡å¤æ¿€åŒ–æ£€æµ‹ (å¦‚ "å•Šå•Šå•Šå•Š" è¡¨ç¤ºæƒ…ç»ªå¤±æ§)
        if self.re_repeat_chars.search(text):
            global_boost += 0.3

        # 3. ç–‘é—®å¥æŠ‘åˆ¶æœºåˆ¶ (é˜²æ­¢è¯¯åˆ¤ï¼š "ä½ ä¼šéš¾è¿‡å—ï¼Ÿ" ä¸åº”è§¦å‘å®‰æ…°)
        # å¦‚æœæ˜¯é’ˆå¯¹æœºå™¨äººçš„æé—®ï¼Œå¤§å¹…é™ä½æƒé‡
        is_question_to_bot = bool(self.re_question.search(text))
        question_penalty = 0.4 if is_question_to_bot else 1.0

        # --- Step 2: èŠ‚ç‚¹éå†ä¸è®¡ç®— ---
        for tag, data in self.EMOTION_NODES.items():
            base = data['base_score']
            priority = data['priority']
            
            # A. å…³é”®è¯åŒ¹é… (å¸¦å‰ç½®ä¿®é¥°ç¬¦è®¡ç®—)
            for kw in data['keywords']:
                if kw in text_lower:
                    for match in re.finditer(re.escape(kw), text_lower):
                        score = self._calculate_node_weight(text_lower, match.start(), match.end(), base)
                        final_scores[tag] += score
                        max_priorities[tag] = max(max_priorities[tag], priority)

            # B. æ­£åˆ™è¡¨è¾¾å¼åŒ¹é… (æ›´ç²¾å‡†çš„å¥å¼ï¼ŒåŸºç¡€åˆ†+2)
            for pattern in data['regex']:
                for match in re.finditer(pattern, text_lower):
                    # æ­£åˆ™é€šå¸¸æ„å‘³ç€æ›´å®Œæ•´çš„è¯­ä¹‰ï¼Œç»™äºˆæ›´é«˜æƒé‡
                    score = self._calculate_node_weight(text_lower, match.start(), match.end(), base + 2.0)
                    final_scores[tag] += score
                    max_priorities[tag] = max(max_priorities[tag], priority)

            # C. Emoji åŒ¹é… (æ¯ä¸ªEmoji +1.5åˆ†)
            for emoji in data['emojis']:
                if emoji in text:
                    count = text.count(emoji)
                    final_scores[tag] += 1.5 * count

        # --- Step 3: å€™é€‰ç­›é€‰ä¸å†³ç­– ---
        candidates = {}
        for k, v in final_scores.items():
            # åº”ç”¨å…¨å±€åŠ æˆå’Œæƒ©ç½š
            final_v = v * global_boost * question_penalty
            # è¿‡æ»¤æ‰éæ­£åˆ† (è¢«å¦å®šè¯æŠµæ¶ˆçš„)
            if final_v > 0:
                candidates[k] = final_v

        if not candidates:
            return None, 0

        # æ’åºç­–ç•¥ï¼šä¼˜å…ˆçº§(Priority) > åˆ†æ•°(Score)
        sorted_candidates = sorted(
            [(k, v, max_priorities[k]) for k, v in candidates.items()],
            key=lambda item: (item[2], item[1]),
            reverse=True
        )

        best_tag, best_score, best_priority = sorted_candidates[0]

        # --- Step 4: åŠ¨æ€é˜ˆå€¼é—¨æ§ ---
        # ç´§æ€¥æƒ…ç»ª(Priority>0) é—¨æ§›ä½ï¼Œå®å¯è¯¯è§¦ä¹Ÿè¦å›åº”
        # æ™®é€šæƒ…ç»ª(Priority=0) é—¨æ§›é«˜ï¼Œé˜²æ­¢æ—¥å¸¸é—²èŠå¹²æ‰°
        threshold = 2.5 if best_priority > 0 else 3.5
        
        if best_score < threshold:
            return None, 0

        return best_tag, best_score

    def _calculate_node_weight(self, text: str, start_idx: int, end_idx: int, base_score: float) -> float:
        """
        è®¡ç®—å•ä¸ªåŒ¹é…é¡¹çš„æƒé‡ï¼Œå‘å‰æ»‘åŠ¨çª—å£æœç´¢ä¿®é¥°ç¬¦
        """
        window_start = max(0, start_idx - self.WINDOW_SIZE)
        window_text = text[window_start:start_idx]
        
        multiplier = 1.0
        
        for mod_type, mod_data in self.MODIFIERS.items():
            for word in mod_data['words']:
                if word in window_text:
                    multiplier *= mod_data['weight']
                    # æ‰¾åˆ°ä¸€ä¸ªåŒç±»ä¿®é¥°ç¬¦å³è·³å‡ºè¯¥ç±»åˆ« (é¿å… "éå¸¸è¶…çº§" å¯¼è‡´æ•°å€¼è†¨èƒ€)
                    break 
        
        return base_score * multiplier